Terminals unused in grammar

   VOID


Grammar

    0 $accept: program $end

    1 program: CLASS IDENTIFIER O_CUR_BRACE field_decls method_decls C_CUR_BRACE
    2        | CLASS IDENTIFIER O_CUR_BRACE field_decls C_CUR_BRACE
    3        | CLASS IDENTIFIER O_CUR_BRACE method_decls C_CUR_BRACE
    4        | CLASS IDENTIFIER O_CUR_BRACE C_CUR_BRACE

    5 field_decls: field_decl
    6            | field_decls field_decl

    7 field_decl: type identifiers SEMICOLON
    8           | type arr_identifiers SEMICOLON
    9           | type identifiers COMMA arr_identifiers SEMICOLON
   10           | type arr_identifiers COMMA identifiers SEMICOLON

   11 identifiers: IDENTIFIER
   12            | identifiers COMMA IDENTIFIER

   13 arr_identifiers: arr_identifier
   14                | arr_identifiers COMMA arr_identifier

   15 arr_identifier: IDENTIFIER O_BRACE INT_LITERAL C_BRACE

   16 method_decls: method_decl
   17             | method_decls method_decl

   18 method_decl: type IDENTIFIER O_PAREN type_identifiers C_PAREN block
   19            | type IDENTIFIER O_PAREN C_PAREN block

   20 var_decls: var_decl
   21          | var_decls var_decl

   22 var_decl: type identifiers SEMICOLON
   23         | type arr_identifiers SEMICOLON

   24 type_identifiers: type_identifier
   25                 | type_identifiers COMMA type_identifier

   26 type_identifier: type IDENTIFIER

   27 block: O_CUR_BRACE var_decls statements C_CUR_BRACE
   28      | O_CUR_BRACE statements C_CUR_BRACE
   29      | O_CUR_BRACE var_decls C_CUR_BRACE
   30      | O_CUR_BRACE C_CUR_BRACE

   31 statements: statement
   32           | statements statement

   33 statement: block
   34          | location assign_op expr SEMICOLON
   35          | method_call SEMICOLON
   36          | IF O_PAREN expr C_PAREN block ELSE block
   37          | IF O_PAREN expr C_PAREN block
   38          | FOR IDENTIFIER EQUAL expr COMMA expr block
   39          | RETURN expr SEMICOLON
   40          | RETURN SEMICOLON
   41          | BREAK SEMICOLON
   42          | CONTINUE SEMICOLON
   43          | SEMICOLON

   44 assign_op: EQUAL
   45          | PLUS_EQUAL
   46          | MINUS_EQUAL

   47 location: IDENTIFIER
   48         | IDENTIFIER O_BRACE expr C_BRACE

   49 method_call: IDENTIFIER O_PAREN expressions C_PAREN
   50            | IDENTIFIER O_PAREN C_PAREN
   51            | CALLOUT O_PAREN STRING_LITERAL C_PAREN
   52            | CALLOUT O_PAREN STRING_LITERAL COMMA callout_args C_PAREN

   53 callout_args: callout_arg
   54             | callout_args COMMA callout_arg

   55 callout_arg: expr
   56            | STRING_LITERAL

   57 expressions: expr
   58            | expressions COMMA expr

   59 expr: location
   60     | method_call
   61     | literal
   62     | O_PAREN expr C_PAREN
   63     | expr OP_PLUS expr
   64     | expr OP_MINUS expr
   65     | expr OP_MULTIPLY expr
   66     | expr OP_DIVIDE expr
   67     | expr OP_MODULO expr
   68     | expr OP_LESS_THAN expr
   69     | expr OP_GREATER_THAN expr
   70     | expr OP_LESS_EQUAL expr
   71     | expr OP_GREATER_EQUAL expr
   72     | expr OP_EQUAL_EQUAL expr
   73     | expr OP_NOT_EQUAL expr
   74     | expr OP_LOGICAL_OR expr
   75     | expr OP_LOGICAL_AND expr
   76     | OP_NOT expr
   77     | OP_MINUS expr

   78 literal: INT_LITERAL
   79        | CHAR_LITERAL
   80        | TRUE
   81        | FALSE

   82 type: TYPE_INTEGER
   83     | TYPE_BOOLEAN
   84     | TYPE_VOID


Terminals, with rules where they appear

$end (0) 0
error (256)
BREAK (258) 41
CALLOUT (259) 51 52
CLASS (260) 1 2 3 4
CONTINUE (261) 42
ELSE (262) 36
FALSE (263) 81
FOR (264) 38
IF (265) 36 37
RETURN (266) 39 40
TRUE (267) 80
VOID (268)
COMMA (269) 9 10 12 14 25 38 52 54 58
TYPE_BOOLEAN (270) 83
TYPE_INTEGER (271) 82
TYPE_VOID (272) 84
O_CUR_BRACE (273) 1 2 3 4 27 28 29 30
C_CUR_BRACE (274) 1 2 3 4 27 28 29 30
O_PAREN (275) 18 19 36 37 49 50 51 52 62
C_PAREN (276) 18 19 36 37 49 50 51 52 62
SEMICOLON (277) 7 8 9 10 22 23 34 35 39 40 41 42 43
O_BRACE (278) 15 48
C_BRACE (279) 15 48
OP_LOGICAL_OR (280) 74
OP_LOGICAL_AND (281) 75
EQUAL (282) 38 44
PLUS_EQUAL (283) 45
MINUS_EQUAL (284) 46
OP_NOT_EQUAL (285) 73
OP_EQUAL_EQUAL (286) 72
OP_LESS_THAN (287) 68
OP_GREATER_THAN (288) 69
OP_LESS_EQUAL (289) 70
OP_GREATER_EQUAL (290) 71
OP_PLUS (291) 63
OP_MINUS (292) 64 77
OP_MULTIPLY (293) 65
OP_DIVIDE (294) 66
OP_MODULO (295) 67
OP_NOT (296) 76
OP_UMINUS (297)
IDENTIFIER (298) 1 2 3 4 11 12 15 18 19 26 38 47 48 49 50
INT_LITERAL (299) 15 78
STRING_LITERAL (300) 51 52 56
CHAR_LITERAL (301) 79


Nonterminals, with rules where they appear

$accept (47)
    on left: 0
program (48)
    on left: 1 2 3 4, on right: 0
field_decls (49)
    on left: 5 6, on right: 1 2 6
field_decl (50)
    on left: 7 8 9 10, on right: 5 6
identifiers (51)
    on left: 11 12, on right: 7 9 10 12 22
arr_identifiers (52)
    on left: 13 14, on right: 8 9 10 14 23
arr_identifier (53)
    on left: 15, on right: 13 14
method_decls (54)
    on left: 16 17, on right: 1 3 17
method_decl (55)
    on left: 18 19, on right: 16 17
var_decls (56)
    on left: 20 21, on right: 21 27 29
var_decl (57)
    on left: 22 23, on right: 20 21
type_identifiers (58)
    on left: 24 25, on right: 18 25
type_identifier (59)
    on left: 26, on right: 24 25
block (60)
    on left: 27 28 29 30, on right: 18 19 33 36 37 38
statements (61)
    on left: 31 32, on right: 27 28 32
statement (62)
    on left: 33 34 35 36 37 38 39 40 41 42 43, on right: 31 32
assign_op (63)
    on left: 44 45 46, on right: 34
location (64)
    on left: 47 48, on right: 34 59
method_call (65)
    on left: 49 50 51 52, on right: 35 60
callout_args (66)
    on left: 53 54, on right: 52 54
callout_arg (67)
    on left: 55 56, on right: 53 54
expressions (68)
    on left: 57 58, on right: 49 58
expr (69)
    on left: 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76
    77, on right: 34 36 37 38 39 48 55 57 58 62 63 64 65 66 67 68 69
    70 71 72 73 74 75 76 77
literal (70)
    on left: 78 79 80 81, on right: 61
type (71)
    on left: 82 83 84, on right: 7 8 9 10 18 19 22 23 26


State 0

    0 $accept: . program $end

    CLASS  shift, and go to state 1

    program  go to state 2


State 1

    1 program: CLASS . IDENTIFIER O_CUR_BRACE field_decls method_decls C_CUR_BRACE
    2        | CLASS . IDENTIFIER O_CUR_BRACE field_decls C_CUR_BRACE
    3        | CLASS . IDENTIFIER O_CUR_BRACE method_decls C_CUR_BRACE
    4        | CLASS . IDENTIFIER O_CUR_BRACE C_CUR_BRACE

    IDENTIFIER  shift, and go to state 3


State 2

    0 $accept: program . $end

    $end  shift, and go to state 4


State 3

    1 program: CLASS IDENTIFIER . O_CUR_BRACE field_decls method_decls C_CUR_BRACE
    2        | CLASS IDENTIFIER . O_CUR_BRACE field_decls C_CUR_BRACE
    3        | CLASS IDENTIFIER . O_CUR_BRACE method_decls C_CUR_BRACE
    4        | CLASS IDENTIFIER . O_CUR_BRACE C_CUR_BRACE

    O_CUR_BRACE  shift, and go to state 5


State 4

    0 $accept: program $end .

    $default  accept


State 5

    1 program: CLASS IDENTIFIER O_CUR_BRACE . field_decls method_decls C_CUR_BRACE
    2        | CLASS IDENTIFIER O_CUR_BRACE . field_decls C_CUR_BRACE
    3        | CLASS IDENTIFIER O_CUR_BRACE . method_decls C_CUR_BRACE
    4        | CLASS IDENTIFIER O_CUR_BRACE . C_CUR_BRACE

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    C_CUR_BRACE   shift, and go to state 9

    field_decls   go to state 10
    field_decl    go to state 11
    method_decls  go to state 12
    method_decl   go to state 13
    type          go to state 14


State 6

   83 type: TYPE_BOOLEAN .

    $default  reduce using rule 83 (type)


State 7

   82 type: TYPE_INTEGER .

    $default  reduce using rule 82 (type)


State 8

   84 type: TYPE_VOID .

    $default  reduce using rule 84 (type)


State 9

    4 program: CLASS IDENTIFIER O_CUR_BRACE C_CUR_BRACE .

    $default  reduce using rule 4 (program)


State 10

    1 program: CLASS IDENTIFIER O_CUR_BRACE field_decls . method_decls C_CUR_BRACE
    2        | CLASS IDENTIFIER O_CUR_BRACE field_decls . C_CUR_BRACE
    6 field_decls: field_decls . field_decl

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    C_CUR_BRACE   shift, and go to state 15

    field_decl    go to state 16
    method_decls  go to state 17
    method_decl   go to state 13
    type          go to state 14


State 11

    5 field_decls: field_decl .

    $default  reduce using rule 5 (field_decls)


State 12

    3 program: CLASS IDENTIFIER O_CUR_BRACE method_decls . C_CUR_BRACE
   17 method_decls: method_decls . method_decl

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    C_CUR_BRACE   shift, and go to state 18

    method_decl  go to state 19
    type         go to state 20


State 13

   16 method_decls: method_decl .

    $default  reduce using rule 16 (method_decls)


State 14

    7 field_decl: type . identifiers SEMICOLON
    8           | type . arr_identifiers SEMICOLON
    9           | type . identifiers COMMA arr_identifiers SEMICOLON
   10           | type . arr_identifiers COMMA identifiers SEMICOLON
   18 method_decl: type . IDENTIFIER O_PAREN type_identifiers C_PAREN block
   19            | type . IDENTIFIER O_PAREN C_PAREN block

    IDENTIFIER  shift, and go to state 21

    identifiers      go to state 22
    arr_identifiers  go to state 23
    arr_identifier   go to state 24


State 15

    2 program: CLASS IDENTIFIER O_CUR_BRACE field_decls C_CUR_BRACE .

    $default  reduce using rule 2 (program)


State 16

    6 field_decls: field_decls field_decl .

    $default  reduce using rule 6 (field_decls)


State 17

    1 program: CLASS IDENTIFIER O_CUR_BRACE field_decls method_decls . C_CUR_BRACE
   17 method_decls: method_decls . method_decl

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    C_CUR_BRACE   shift, and go to state 25

    method_decl  go to state 19
    type         go to state 20


State 18

    3 program: CLASS IDENTIFIER O_CUR_BRACE method_decls C_CUR_BRACE .

    $default  reduce using rule 3 (program)


State 19

   17 method_decls: method_decls method_decl .

    $default  reduce using rule 17 (method_decls)


State 20

   18 method_decl: type . IDENTIFIER O_PAREN type_identifiers C_PAREN block
   19            | type . IDENTIFIER O_PAREN C_PAREN block

    IDENTIFIER  shift, and go to state 26


State 21

   11 identifiers: IDENTIFIER .
   15 arr_identifier: IDENTIFIER . O_BRACE INT_LITERAL C_BRACE
   18 method_decl: type IDENTIFIER . O_PAREN type_identifiers C_PAREN block
   19            | type IDENTIFIER . O_PAREN C_PAREN block

    O_PAREN  shift, and go to state 27
    O_BRACE  shift, and go to state 28

    $default  reduce using rule 11 (identifiers)


State 22

    7 field_decl: type identifiers . SEMICOLON
    9           | type identifiers . COMMA arr_identifiers SEMICOLON
   12 identifiers: identifiers . COMMA IDENTIFIER

    COMMA      shift, and go to state 29
    SEMICOLON  shift, and go to state 30


State 23

    8 field_decl: type arr_identifiers . SEMICOLON
   10           | type arr_identifiers . COMMA identifiers SEMICOLON
   14 arr_identifiers: arr_identifiers . COMMA arr_identifier

    COMMA      shift, and go to state 31
    SEMICOLON  shift, and go to state 32


State 24

   13 arr_identifiers: arr_identifier .

    $default  reduce using rule 13 (arr_identifiers)


State 25

    1 program: CLASS IDENTIFIER O_CUR_BRACE field_decls method_decls C_CUR_BRACE .

    $default  reduce using rule 1 (program)


State 26

   18 method_decl: type IDENTIFIER . O_PAREN type_identifiers C_PAREN block
   19            | type IDENTIFIER . O_PAREN C_PAREN block

    O_PAREN  shift, and go to state 27


State 27

   18 method_decl: type IDENTIFIER O_PAREN . type_identifiers C_PAREN block
   19            | type IDENTIFIER O_PAREN . C_PAREN block

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    C_PAREN       shift, and go to state 33

    type_identifiers  go to state 34
    type_identifier   go to state 35
    type              go to state 36


State 28

   15 arr_identifier: IDENTIFIER O_BRACE . INT_LITERAL C_BRACE

    INT_LITERAL  shift, and go to state 37


State 29

    9 field_decl: type identifiers COMMA . arr_identifiers SEMICOLON
   12 identifiers: identifiers COMMA . IDENTIFIER

    IDENTIFIER  shift, and go to state 38

    arr_identifiers  go to state 39
    arr_identifier   go to state 24


State 30

    7 field_decl: type identifiers SEMICOLON .

    $default  reduce using rule 7 (field_decl)


State 31

   10 field_decl: type arr_identifiers COMMA . identifiers SEMICOLON
   14 arr_identifiers: arr_identifiers COMMA . arr_identifier

    IDENTIFIER  shift, and go to state 40

    identifiers     go to state 41
    arr_identifier  go to state 42


State 32

    8 field_decl: type arr_identifiers SEMICOLON .

    $default  reduce using rule 8 (field_decl)


State 33

   19 method_decl: type IDENTIFIER O_PAREN C_PAREN . block

    O_CUR_BRACE  shift, and go to state 43

    block  go to state 44


State 34

   18 method_decl: type IDENTIFIER O_PAREN type_identifiers . C_PAREN block
   25 type_identifiers: type_identifiers . COMMA type_identifier

    COMMA    shift, and go to state 45
    C_PAREN  shift, and go to state 46


State 35

   24 type_identifiers: type_identifier .

    $default  reduce using rule 24 (type_identifiers)


State 36

   26 type_identifier: type . IDENTIFIER

    IDENTIFIER  shift, and go to state 47


State 37

   15 arr_identifier: IDENTIFIER O_BRACE INT_LITERAL . C_BRACE

    C_BRACE  shift, and go to state 48


State 38

   12 identifiers: identifiers COMMA IDENTIFIER .
   15 arr_identifier: IDENTIFIER . O_BRACE INT_LITERAL C_BRACE

    O_BRACE  shift, and go to state 28

    $default  reduce using rule 12 (identifiers)


State 39

    9 field_decl: type identifiers COMMA arr_identifiers . SEMICOLON
   14 arr_identifiers: arr_identifiers . COMMA arr_identifier

    COMMA      shift, and go to state 49
    SEMICOLON  shift, and go to state 50


State 40

   11 identifiers: IDENTIFIER .
   15 arr_identifier: IDENTIFIER . O_BRACE INT_LITERAL C_BRACE

    O_BRACE  shift, and go to state 28

    $default  reduce using rule 11 (identifiers)


State 41

   10 field_decl: type arr_identifiers COMMA identifiers . SEMICOLON
   12 identifiers: identifiers . COMMA IDENTIFIER

    COMMA      shift, and go to state 51
    SEMICOLON  shift, and go to state 52


State 42

   14 arr_identifiers: arr_identifiers COMMA arr_identifier .

    $default  reduce using rule 14 (arr_identifiers)


State 43

   27 block: O_CUR_BRACE . var_decls statements C_CUR_BRACE
   28      | O_CUR_BRACE . statements C_CUR_BRACE
   29      | O_CUR_BRACE . var_decls C_CUR_BRACE
   30      | O_CUR_BRACE . C_CUR_BRACE

    BREAK         shift, and go to state 53
    CALLOUT       shift, and go to state 54
    CONTINUE      shift, and go to state 55
    FOR           shift, and go to state 56
    IF            shift, and go to state 57
    RETURN        shift, and go to state 58
    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    O_CUR_BRACE   shift, and go to state 43
    C_CUR_BRACE   shift, and go to state 59
    SEMICOLON     shift, and go to state 60
    IDENTIFIER    shift, and go to state 61

    var_decls    go to state 62
    var_decl     go to state 63
    block        go to state 64
    statements   go to state 65
    statement    go to state 66
    location     go to state 67
    method_call  go to state 68
    type         go to state 69


State 44

   19 method_decl: type IDENTIFIER O_PAREN C_PAREN block .

    $default  reduce using rule 19 (method_decl)


State 45

   25 type_identifiers: type_identifiers COMMA . type_identifier

    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8

    type_identifier  go to state 70
    type             go to state 36


State 46

   18 method_decl: type IDENTIFIER O_PAREN type_identifiers C_PAREN . block

    O_CUR_BRACE  shift, and go to state 43

    block  go to state 71


State 47

   26 type_identifier: type IDENTIFIER .

    $default  reduce using rule 26 (type_identifier)


State 48

   15 arr_identifier: IDENTIFIER O_BRACE INT_LITERAL C_BRACE .

    $default  reduce using rule 15 (arr_identifier)


State 49

   14 arr_identifiers: arr_identifiers COMMA . arr_identifier

    IDENTIFIER  shift, and go to state 72

    arr_identifier  go to state 42


State 50

    9 field_decl: type identifiers COMMA arr_identifiers SEMICOLON .

    $default  reduce using rule 9 (field_decl)


State 51

   12 identifiers: identifiers COMMA . IDENTIFIER

    IDENTIFIER  shift, and go to state 73


State 52

   10 field_decl: type arr_identifiers COMMA identifiers SEMICOLON .

    $default  reduce using rule 10 (field_decl)


State 53

   41 statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 74


State 54

   51 method_call: CALLOUT . O_PAREN STRING_LITERAL C_PAREN
   52            | CALLOUT . O_PAREN STRING_LITERAL COMMA callout_args C_PAREN

    O_PAREN  shift, and go to state 75


State 55

   42 statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 76


State 56

   38 statement: FOR . IDENTIFIER EQUAL expr COMMA expr block

    IDENTIFIER  shift, and go to state 77


State 57

   36 statement: IF . O_PAREN expr C_PAREN block ELSE block
   37          | IF . O_PAREN expr C_PAREN block

    O_PAREN  shift, and go to state 78


State 58

   39 statement: RETURN . expr SEMICOLON
   40          | RETURN . SEMICOLON

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    SEMICOLON     shift, and go to state 82
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 89
    literal      go to state 90


State 59

   30 block: O_CUR_BRACE C_CUR_BRACE .

    $default  reduce using rule 30 (block)


State 60

   43 statement: SEMICOLON .

    $default  reduce using rule 43 (statement)


State 61

   47 location: IDENTIFIER .
   48         | IDENTIFIER . O_BRACE expr C_BRACE
   49 method_call: IDENTIFIER . O_PAREN expressions C_PAREN
   50            | IDENTIFIER . O_PAREN C_PAREN

    O_PAREN  shift, and go to state 91
    O_BRACE  shift, and go to state 92

    $default  reduce using rule 47 (location)


State 62

   21 var_decls: var_decls . var_decl
   27 block: O_CUR_BRACE var_decls . statements C_CUR_BRACE
   29      | O_CUR_BRACE var_decls . C_CUR_BRACE

    BREAK         shift, and go to state 53
    CALLOUT       shift, and go to state 54
    CONTINUE      shift, and go to state 55
    FOR           shift, and go to state 56
    IF            shift, and go to state 57
    RETURN        shift, and go to state 58
    TYPE_BOOLEAN  shift, and go to state 6
    TYPE_INTEGER  shift, and go to state 7
    TYPE_VOID     shift, and go to state 8
    O_CUR_BRACE   shift, and go to state 43
    C_CUR_BRACE   shift, and go to state 93
    SEMICOLON     shift, and go to state 60
    IDENTIFIER    shift, and go to state 61

    var_decl     go to state 94
    block        go to state 64
    statements   go to state 95
    statement    go to state 66
    location     go to state 67
    method_call  go to state 68
    type         go to state 69


State 63

   20 var_decls: var_decl .

    $default  reduce using rule 20 (var_decls)


State 64

   33 statement: block .

    $default  reduce using rule 33 (statement)


State 65

   28 block: O_CUR_BRACE statements . C_CUR_BRACE
   32 statements: statements . statement

    BREAK        shift, and go to state 53
    CALLOUT      shift, and go to state 54
    CONTINUE     shift, and go to state 55
    FOR          shift, and go to state 56
    IF           shift, and go to state 57
    RETURN       shift, and go to state 58
    O_CUR_BRACE  shift, and go to state 43
    C_CUR_BRACE  shift, and go to state 96
    SEMICOLON    shift, and go to state 60
    IDENTIFIER   shift, and go to state 61

    block        go to state 64
    statement    go to state 97
    location     go to state 67
    method_call  go to state 68


State 66

   31 statements: statement .

    $default  reduce using rule 31 (statements)


State 67

   34 statement: location . assign_op expr SEMICOLON

    EQUAL        shift, and go to state 98
    PLUS_EQUAL   shift, and go to state 99
    MINUS_EQUAL  shift, and go to state 100

    assign_op  go to state 101


State 68

   35 statement: method_call . SEMICOLON

    SEMICOLON  shift, and go to state 102


State 69

   22 var_decl: type . identifiers SEMICOLON
   23         | type . arr_identifiers SEMICOLON

    IDENTIFIER  shift, and go to state 40

    identifiers      go to state 103
    arr_identifiers  go to state 104
    arr_identifier   go to state 24


State 70

   25 type_identifiers: type_identifiers COMMA type_identifier .

    $default  reduce using rule 25 (type_identifiers)


State 71

   18 method_decl: type IDENTIFIER O_PAREN type_identifiers C_PAREN block .

    $default  reduce using rule 18 (method_decl)


State 72

   15 arr_identifier: IDENTIFIER . O_BRACE INT_LITERAL C_BRACE

    O_BRACE  shift, and go to state 28


State 73

   12 identifiers: identifiers COMMA IDENTIFIER .

    $default  reduce using rule 12 (identifiers)


State 74

   41 statement: BREAK SEMICOLON .

    $default  reduce using rule 41 (statement)


State 75

   51 method_call: CALLOUT O_PAREN . STRING_LITERAL C_PAREN
   52            | CALLOUT O_PAREN . STRING_LITERAL COMMA callout_args C_PAREN

    STRING_LITERAL  shift, and go to state 105


State 76

   42 statement: CONTINUE SEMICOLON .

    $default  reduce using rule 42 (statement)


State 77

   38 statement: FOR IDENTIFIER . EQUAL expr COMMA expr block

    EQUAL  shift, and go to state 106


State 78

   36 statement: IF O_PAREN . expr C_PAREN block ELSE block
   37          | IF O_PAREN . expr C_PAREN block

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 107
    literal      go to state 90


State 79

   81 literal: FALSE .

    $default  reduce using rule 81 (literal)


State 80

   80 literal: TRUE .

    $default  reduce using rule 80 (literal)


State 81

   62 expr: O_PAREN . expr C_PAREN

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 108
    literal      go to state 90


State 82

   40 statement: RETURN SEMICOLON .

    $default  reduce using rule 40 (statement)


State 83

   77 expr: OP_MINUS . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 109
    literal      go to state 90


State 84

   76 expr: OP_NOT . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 110
    literal      go to state 90


State 85

   78 literal: INT_LITERAL .

    $default  reduce using rule 78 (literal)


State 86

   79 literal: CHAR_LITERAL .

    $default  reduce using rule 79 (literal)


State 87

   59 expr: location .

    $default  reduce using rule 59 (expr)


State 88

   60 expr: method_call .

    $default  reduce using rule 60 (expr)


State 89

   39 statement: RETURN expr . SEMICOLON
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    SEMICOLON         shift, and go to state 111
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 90

   61 expr: literal .

    $default  reduce using rule 61 (expr)


State 91

   49 method_call: IDENTIFIER O_PAREN . expressions C_PAREN
   50            | IDENTIFIER O_PAREN . C_PAREN

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    C_PAREN       shift, and go to state 125
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expressions  go to state 126
    expr         go to state 127
    literal      go to state 90


State 92

   48 location: IDENTIFIER O_BRACE . expr C_BRACE

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 128
    literal      go to state 90


State 93

   29 block: O_CUR_BRACE var_decls C_CUR_BRACE .

    $default  reduce using rule 29 (block)


State 94

   21 var_decls: var_decls var_decl .

    $default  reduce using rule 21 (var_decls)


State 95

   27 block: O_CUR_BRACE var_decls statements . C_CUR_BRACE
   32 statements: statements . statement

    BREAK        shift, and go to state 53
    CALLOUT      shift, and go to state 54
    CONTINUE     shift, and go to state 55
    FOR          shift, and go to state 56
    IF           shift, and go to state 57
    RETURN       shift, and go to state 58
    O_CUR_BRACE  shift, and go to state 43
    C_CUR_BRACE  shift, and go to state 129
    SEMICOLON    shift, and go to state 60
    IDENTIFIER   shift, and go to state 61

    block        go to state 64
    statement    go to state 97
    location     go to state 67
    method_call  go to state 68


State 96

   28 block: O_CUR_BRACE statements C_CUR_BRACE .

    $default  reduce using rule 28 (block)


State 97

   32 statements: statements statement .

    $default  reduce using rule 32 (statements)


State 98

   44 assign_op: EQUAL .

    $default  reduce using rule 44 (assign_op)


State 99

   45 assign_op: PLUS_EQUAL .

    $default  reduce using rule 45 (assign_op)


State 100

   46 assign_op: MINUS_EQUAL .

    $default  reduce using rule 46 (assign_op)


State 101

   34 statement: location assign_op . expr SEMICOLON

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 130
    literal      go to state 90


State 102

   35 statement: method_call SEMICOLON .

    $default  reduce using rule 35 (statement)


State 103

   12 identifiers: identifiers . COMMA IDENTIFIER
   22 var_decl: type identifiers . SEMICOLON

    COMMA      shift, and go to state 51
    SEMICOLON  shift, and go to state 131


State 104

   14 arr_identifiers: arr_identifiers . COMMA arr_identifier
   23 var_decl: type arr_identifiers . SEMICOLON

    COMMA      shift, and go to state 49
    SEMICOLON  shift, and go to state 132


State 105

   51 method_call: CALLOUT O_PAREN STRING_LITERAL . C_PAREN
   52            | CALLOUT O_PAREN STRING_LITERAL . COMMA callout_args C_PAREN

    COMMA    shift, and go to state 133
    C_PAREN  shift, and go to state 134


State 106

   38 statement: FOR IDENTIFIER EQUAL . expr COMMA expr block

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 135
    literal      go to state 90


State 107

   36 statement: IF O_PAREN expr . C_PAREN block ELSE block
   37          | IF O_PAREN expr . C_PAREN block
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    C_PAREN           shift, and go to state 136
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 108

   62 expr: O_PAREN expr . C_PAREN
   63     | expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    C_PAREN           shift, and go to state 137
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 109

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr
   77     | OP_MINUS expr .

    $default  reduce using rule 77 (expr)


State 110

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr
   76     | OP_NOT expr .

    $default  reduce using rule 76 (expr)


State 111

   39 statement: RETURN expr SEMICOLON .

    $default  reduce using rule 39 (statement)


State 112

   74 expr: expr OP_LOGICAL_OR . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 138
    literal      go to state 90


State 113

   75 expr: expr OP_LOGICAL_AND . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 139
    literal      go to state 90


State 114

   73 expr: expr OP_NOT_EQUAL . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 140
    literal      go to state 90


State 115

   72 expr: expr OP_EQUAL_EQUAL . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 141
    literal      go to state 90


State 116

   68 expr: expr OP_LESS_THAN . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 142
    literal      go to state 90


State 117

   69 expr: expr OP_GREATER_THAN . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 143
    literal      go to state 90


State 118

   70 expr: expr OP_LESS_EQUAL . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 144
    literal      go to state 90


State 119

   71 expr: expr OP_GREATER_EQUAL . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 145
    literal      go to state 90


State 120

   63 expr: expr OP_PLUS . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 146
    literal      go to state 90


State 121

   64 expr: expr OP_MINUS . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 147
    literal      go to state 90


State 122

   65 expr: expr OP_MULTIPLY . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 148
    literal      go to state 90


State 123

   66 expr: expr OP_DIVIDE . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 149
    literal      go to state 90


State 124

   67 expr: expr OP_MODULO . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 150
    literal      go to state 90


State 125

   50 method_call: IDENTIFIER O_PAREN C_PAREN .

    $default  reduce using rule 50 (method_call)


State 126

   49 method_call: IDENTIFIER O_PAREN expressions . C_PAREN
   58 expressions: expressions . COMMA expr

    COMMA    shift, and go to state 151
    C_PAREN  shift, and go to state 152


State 127

   57 expressions: expr .
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 57 (expressions)


State 128

   48 location: IDENTIFIER O_BRACE expr . C_BRACE
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    C_BRACE           shift, and go to state 153
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 129

   27 block: O_CUR_BRACE var_decls statements C_CUR_BRACE .

    $default  reduce using rule 27 (block)


State 130

   34 statement: location assign_op expr . SEMICOLON
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    SEMICOLON         shift, and go to state 154
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 131

   22 var_decl: type identifiers SEMICOLON .

    $default  reduce using rule 22 (var_decl)


State 132

   23 var_decl: type arr_identifiers SEMICOLON .

    $default  reduce using rule 23 (var_decl)


State 133

   52 method_call: CALLOUT O_PAREN STRING_LITERAL COMMA . callout_args C_PAREN

    CALLOUT         shift, and go to state 54
    FALSE           shift, and go to state 79
    TRUE            shift, and go to state 80
    O_PAREN         shift, and go to state 81
    OP_MINUS        shift, and go to state 83
    OP_NOT          shift, and go to state 84
    IDENTIFIER      shift, and go to state 61
    INT_LITERAL     shift, and go to state 85
    STRING_LITERAL  shift, and go to state 155
    CHAR_LITERAL    shift, and go to state 86

    location      go to state 87
    method_call   go to state 88
    callout_args  go to state 156
    callout_arg   go to state 157
    expr          go to state 158
    literal       go to state 90


State 134

   51 method_call: CALLOUT O_PAREN STRING_LITERAL C_PAREN .

    $default  reduce using rule 51 (method_call)


State 135

   38 statement: FOR IDENTIFIER EQUAL expr . COMMA expr block
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    COMMA             shift, and go to state 159
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124


State 136

   36 statement: IF O_PAREN expr C_PAREN . block ELSE block
   37          | IF O_PAREN expr C_PAREN . block

    O_CUR_BRACE  shift, and go to state 43

    block  go to state 160


State 137

   62 expr: O_PAREN expr C_PAREN .

    $default  reduce using rule 62 (expr)


State 138

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   74     | expr OP_LOGICAL_OR expr .
   75     | expr . OP_LOGICAL_AND expr

    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 74 (expr)


State 139

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr
   75     | expr OP_LOGICAL_AND expr .

    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 75 (expr)


State 140

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   73     | expr OP_NOT_EQUAL expr .
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 73 (expr)


State 141

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   72     | expr OP_EQUAL_EQUAL expr .
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 72 (expr)


State 142

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   68     | expr OP_LESS_THAN expr .
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_PLUS      shift, and go to state 120
    OP_MINUS     shift, and go to state 121
    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    OP_LESS_THAN      error (nonassociative)
    OP_GREATER_THAN   error (nonassociative)
    OP_LESS_EQUAL     error (nonassociative)
    OP_GREATER_EQUAL  error (nonassociative)

    $default  reduce using rule 68 (expr)


State 143

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   69     | expr OP_GREATER_THAN expr .
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_PLUS      shift, and go to state 120
    OP_MINUS     shift, and go to state 121
    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    OP_LESS_THAN      error (nonassociative)
    OP_GREATER_THAN   error (nonassociative)
    OP_LESS_EQUAL     error (nonassociative)
    OP_GREATER_EQUAL  error (nonassociative)

    $default  reduce using rule 69 (expr)


State 144

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   70     | expr OP_LESS_EQUAL expr .
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_PLUS      shift, and go to state 120
    OP_MINUS     shift, and go to state 121
    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    OP_LESS_THAN      error (nonassociative)
    OP_GREATER_THAN   error (nonassociative)
    OP_LESS_EQUAL     error (nonassociative)
    OP_GREATER_EQUAL  error (nonassociative)

    $default  reduce using rule 70 (expr)


State 145

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   71     | expr OP_GREATER_EQUAL expr .
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_PLUS      shift, and go to state 120
    OP_MINUS     shift, and go to state 121
    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    OP_LESS_THAN      error (nonassociative)
    OP_GREATER_THAN   error (nonassociative)
    OP_LESS_EQUAL     error (nonassociative)
    OP_GREATER_EQUAL  error (nonassociative)

    $default  reduce using rule 71 (expr)


State 146

   63 expr: expr . OP_PLUS expr
   63     | expr OP_PLUS expr .
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    $default  reduce using rule 63 (expr)


State 147

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   64     | expr OP_MINUS expr .
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_MULTIPLY  shift, and go to state 122
    OP_DIVIDE    shift, and go to state 123
    OP_MODULO    shift, and go to state 124

    $default  reduce using rule 64 (expr)


State 148

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   65     | expr OP_MULTIPLY expr .
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    $default  reduce using rule 65 (expr)


State 149

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   66     | expr OP_DIVIDE expr .
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    $default  reduce using rule 66 (expr)


State 150

   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   67     | expr OP_MODULO expr .
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    $default  reduce using rule 67 (expr)


State 151

   58 expressions: expressions COMMA . expr

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 161
    literal      go to state 90


State 152

   49 method_call: IDENTIFIER O_PAREN expressions C_PAREN .

    $default  reduce using rule 49 (method_call)


State 153

   48 location: IDENTIFIER O_BRACE expr C_BRACE .

    $default  reduce using rule 48 (location)


State 154

   34 statement: location assign_op expr SEMICOLON .

    $default  reduce using rule 34 (statement)


State 155

   56 callout_arg: STRING_LITERAL .

    $default  reduce using rule 56 (callout_arg)


State 156

   52 method_call: CALLOUT O_PAREN STRING_LITERAL COMMA callout_args . C_PAREN
   54 callout_args: callout_args . COMMA callout_arg

    COMMA    shift, and go to state 162
    C_PAREN  shift, and go to state 163


State 157

   53 callout_args: callout_arg .

    $default  reduce using rule 53 (callout_args)


State 158

   55 callout_arg: expr .
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 55 (callout_arg)


State 159

   38 statement: FOR IDENTIFIER EQUAL expr COMMA . expr block

    CALLOUT       shift, and go to state 54
    FALSE         shift, and go to state 79
    TRUE          shift, and go to state 80
    O_PAREN       shift, and go to state 81
    OP_MINUS      shift, and go to state 83
    OP_NOT        shift, and go to state 84
    IDENTIFIER    shift, and go to state 61
    INT_LITERAL   shift, and go to state 85
    CHAR_LITERAL  shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    expr         go to state 164
    literal      go to state 90


State 160

   36 statement: IF O_PAREN expr C_PAREN block . ELSE block
   37          | IF O_PAREN expr C_PAREN block .

    ELSE  shift, and go to state 165

    $default  reduce using rule 37 (statement)


State 161

   58 expressions: expressions COMMA expr .
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    $default  reduce using rule 58 (expressions)


State 162

   54 callout_args: callout_args COMMA . callout_arg

    CALLOUT         shift, and go to state 54
    FALSE           shift, and go to state 79
    TRUE            shift, and go to state 80
    O_PAREN         shift, and go to state 81
    OP_MINUS        shift, and go to state 83
    OP_NOT          shift, and go to state 84
    IDENTIFIER      shift, and go to state 61
    INT_LITERAL     shift, and go to state 85
    STRING_LITERAL  shift, and go to state 155
    CHAR_LITERAL    shift, and go to state 86

    location     go to state 87
    method_call  go to state 88
    callout_arg  go to state 166
    expr         go to state 158
    literal      go to state 90


State 163

   52 method_call: CALLOUT O_PAREN STRING_LITERAL COMMA callout_args C_PAREN .

    $default  reduce using rule 52 (method_call)


State 164

   38 statement: FOR IDENTIFIER EQUAL expr COMMA expr . block
   63 expr: expr . OP_PLUS expr
   64     | expr . OP_MINUS expr
   65     | expr . OP_MULTIPLY expr
   66     | expr . OP_DIVIDE expr
   67     | expr . OP_MODULO expr
   68     | expr . OP_LESS_THAN expr
   69     | expr . OP_GREATER_THAN expr
   70     | expr . OP_LESS_EQUAL expr
   71     | expr . OP_GREATER_EQUAL expr
   72     | expr . OP_EQUAL_EQUAL expr
   73     | expr . OP_NOT_EQUAL expr
   74     | expr . OP_LOGICAL_OR expr
   75     | expr . OP_LOGICAL_AND expr

    O_CUR_BRACE       shift, and go to state 43
    OP_LOGICAL_OR     shift, and go to state 112
    OP_LOGICAL_AND    shift, and go to state 113
    OP_NOT_EQUAL      shift, and go to state 114
    OP_EQUAL_EQUAL    shift, and go to state 115
    OP_LESS_THAN      shift, and go to state 116
    OP_GREATER_THAN   shift, and go to state 117
    OP_LESS_EQUAL     shift, and go to state 118
    OP_GREATER_EQUAL  shift, and go to state 119
    OP_PLUS           shift, and go to state 120
    OP_MINUS          shift, and go to state 121
    OP_MULTIPLY       shift, and go to state 122
    OP_DIVIDE         shift, and go to state 123
    OP_MODULO         shift, and go to state 124

    block  go to state 167


State 165

   36 statement: IF O_PAREN expr C_PAREN block ELSE . block

    O_CUR_BRACE  shift, and go to state 43

    block  go to state 168


State 166

   54 callout_args: callout_args COMMA callout_arg .

    $default  reduce using rule 54 (callout_args)


State 167

   38 statement: FOR IDENTIFIER EQUAL expr COMMA expr block .

    $default  reduce using rule 38 (statement)


State 168

   36 statement: IF O_PAREN expr C_PAREN block ELSE block .

    $default  reduce using rule 36 (statement)
